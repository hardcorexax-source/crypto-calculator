<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stocks Clone - Bybit (TMA Native)</title>
    <!-- Подключаем скрипт Telegram WebApp -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            /* 
               Значения по умолчанию (Fallback), если открыто не в Telegram.
               В Telegram они будут перезаписаны JS-скриптом.
            */
            --bg-color: #000000;
            --card-bg: #1c1c1e;       /* Вторичный фон */
            --text-main: #ffffff;
            --text-sec: #8e8e93;
            --separator: #2c2c2e;
            
            /* Финансовые цвета (оставляем фиксированными для логики) */
            --accent-green: #30d158;
            --accent-red: #ff453a;

            /* Акцентный цвет пользователя Telegram (по дефолту синий) */
            --tg-theme-button-color: #2481cc; 
            --tg-theme-button-text-color: #ffffff;

            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-stack);
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s; /* Плавная смена темы */
        }

        .screen {
            height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .header {
            padding: 40px 20px 10px 20px;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin: 0 0 10px 0;
        }

        .date-label {
            color: var(--text-sec);
            font-size: 30px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .search-bar {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            color: var(--text-sec);
            margin-bottom: 20px;
            font-size: 17px;
        }
        .search-bar svg { fill: var(--text-sec); width: 18px; margin-right: 8px; }

        .stock-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 20px;
        }

        .stock-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid var(--separator);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        /* Эффект нажатия, адаптирующийся под тему */
        .stock-item:active {
            background-color: var(--card-bg); 
            opacity: 0.8;
        }

        .stock-info { width: 30%; }
        .symbol { font-size: 18px; font-weight: 600; display: block; }
        .name { font-size: 13px; color: var(--text-sec); margin-top: 2px; display: block; }

        .mini-chart {
            width: 30%;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mini-chart canvas { width: 100%; height: 100%; }

        .stock-price-block {
            width: 35%;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .price { font-size: 18px; font-weight: 500; margin-bottom: 4px; }
        
        .change-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 500;
            color: white; /* Всегда белый текст на плашках */
            min-width: 70px;
            text-align: center;
            transition: background-color 0.3s;
        }
        
        .up { background-color: var(--accent-green); }
        .down { background-color: var(--accent-red); }
        .text-up { color: var(--accent-green); }
        .text-down { color: var(--accent-red); }

        .detail-view {
            position: fixed;
            top: 80px;
            left: 0;
            width: calc(100% - 80px);
            height: 100%;
            background-color: var(--bg-color); /* Используем основной фон для нативности */
            z-index: 100;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
        }

        .detail-view.active {
            transform: translateY(0);
        }

        .detail-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .close-btn {
            background: var(--card-bg); /* Используем вторичный фон темы */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-main);
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid var(--separator);
        }

        .detail-main {
            padding: 0 20px;
            overflow-y: auto;
            flex: 1;
        }

        .detail-symbol { font-size: 24px; font-weight: 700; }
        .detail-name { font-size: 14px; color: var(--text-sec); display: flex; justify-content: space-between; }
        .detail-price { font-size: 36px; font-weight: 600; margin-top: 5px; font-variant-numeric: tabular-nums; }
        .detail-change { font-size: 16px; font-weight: 500; }

        .hover-date { color: var(--text-sec); font-weight: 500; font-size: 14px; }

        .time-filters-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            margin: 20px 0;
        }

        .time-filters-wrapper::-webkit-scrollbar { display: none; }

        .time-filters {
            display: flex;
            justify-content: flex-start;
            margin: 0;
            padding: 0 5px;
            gap: 8px;
            min-width: min-content;
        }

        .filter-btn {
            background: none;
            border: none;
            color: var(--text-sec);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 5px;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        /* Активная кнопка теперь использует цвет кнопки пользователя Telegram */
        .filter-btn.active { 
            color: var(--tg-theme-button-text-color); 
            background: var(--tg-theme-button-color); 
        }

        .main-chart-container {
            height: 280px;
            width: 100%;
            position: relative;
            margin-bottom: 20px;
            overflow: hidden;
            cursor: crosshair;
        }
        
        .main-chart-container canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .chart-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--tg-theme-button-color); /* Индикатор загрузки в цвет темы */
            font-size: 14px;
            font-weight: 600;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            border-top: 1px solid var(--separator);
            padding-top: 20px;
            margin-top: 10px;
            padding-bottom: 40px;
        }

        .stat-item { display: flex; justify-content: space-between; font-size: 14px; padding: 5px 0; }
        .stat-label { color: var(--text-sec); }
        .stat-val { font-weight: 500; }

        .yahoo-footer {
            margin-top: auto;
            padding: 20px;
            text-align: center;
            color: var(--text-sec);
            font-size: 12px;
            border-top: 1px solid var(--separator);
            background: var(--bg-color);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulse { animation: pulse 1.5s ease-in-out infinite; }

    </style>
</head>
<body>
    <div style="height: 80px">

    </div>
    <div class="screen" id="listScreen">
        <div class="header">
            <div class="date-label">Акции</div>
            <div style="font-size: 30px; font-weight: 700;">28 ноября</div>
            <br>
            <div class="search-bar">
                <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
                Поиск
            </div>
        </div>

        <div class="stock-list" id="stockListContainer"></div>
        
        <div class="yahoo-footer">
            Деловые новости<br>
            Источник: Yahoo Finance (Simulated via Bybit)
        </div>
    </div>

    <!-- DETAIL VIEW -->
    <div class="detail-view" id="detailView">
        <div class="detail-header">
            <div class="close-btn" onclick="closeDetail()">✕</div>
            <!-- Скрываем иконку плюса, оставляем крестик для простоты -->
        </div>
        <div class="detail-main">
            <div class="detail-symbol" id="dSymbol">BTC-USD</div>
            <div class="detail-name">
                <span id="dName">Bitcoin USD</span>
                <span id="dHoverDate" class="hover-date"></span>
            </div>
            <div class="detail-price" id="dPrice">--</div>
            <div class="detail-change" id="dChange">--</div>

            <div class="time-filters-wrapper">
                <div class="time-filters">
                    <button class="filter-btn" data-interval="1" data-limit="60">1М</button>
                    <button class="filter-btn" data-interval="5" data-limit="60">5М</button>
                    <button class="filter-btn" data-interval="15" data-limit="60">15М</button>
                    <button class="filter-btn" data-interval="60" data-limit="48">1Ч</button>
                    <button class="filter-btn" data-interval="240" data-limit="42">4Ч</button>
                    <button class="filter-btn active" data-interval="D" data-limit="30">1Д</button>
                    <button class="filter-btn" data-interval="D" data-limit="90">3М</button>
                    <button class="filter-btn" data-interval="W" data-limit="52">1Г</button>
                </div>
            </div>

            <div class="main-chart-container" id="chartContainer">
                <canvas id="mainChart"></canvas>
                <div class="chart-loading pulse" id="chartLoading" style="display: none;">Загрузка...</div>
            </div>

            <div class="stats-grid">
                <div class="stat-item"><span class="stat-label">Открытие</span><span class="stat-val" id="sOpen">--</span></div>
                <div class="stat-item"><span class="stat-label">Объем</span><span class="stat-val" id="sVol">--</span></div>
                <div class="stat-item"><span class="stat-label">Максимум</span><span class="stat-val" id="sHigh">--</span></div>
                <div class="stat-item"><span class="stat-label">Мин. за 24ч</span><span class="stat-val" id="sLow24">--</span></div>
                <div class="stat-item"><span class="stat-label">Минимум</span><span class="stat-val" id="sLow">--</span></div>
                <div class="stat-item"><span class="stat-label">Макс. за 24ч</span><span class="stat-val" id="sHigh24">--</span></div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. TELEGRAM THEME LOGIC ---
        function applyTelegramTheme() {
            const tg = window.Telegram.WebApp;
            if (tg) {
                tg.expand(); // Разворачиваем на весь экран
                tg.disableVerticalSwipes();
                tg.requestFullscreen();
                
                // Применяем параметры темы, если они доступны
                if (tg.themeParams) {
                    const p = tg.themeParams;
                    const r = document.documentElement.style;

                    if (p.bg_color) r.setProperty('--bg-color', p.bg_color);
                    if (p.secondary_bg_color) r.setProperty('--card-bg', p.secondary_bg_color);
                    if (p.text_color) r.setProperty('--text-main', p.text_color);
                    if (p.hint_color) r.setProperty('--text-sec', p.hint_color);
                    if (p.button_color) r.setProperty('--tg-theme-button-color', p.button_color);
                    if (p.button_text_color) r.setProperty('--tg-theme-button-text-color', p.button_text_color);
                    
                    // Для сепаратора используем hint_color с прозрачностью, если нет специфичного цвета
                    if (p.section_separator_color) {
                         r.setProperty('--separator', p.section_separator_color);
                    } else if (p.hint_color) {
                         r.setProperty('--separator', p.hint_color + '33'); // 20% opacity
                    }
                }
            }
        }

        // --- 2. CONFIG & STATE ---
        const WATCHLIST = [
            { symbol: 'BTCUSDT', name: 'Bitcoin USD', display: 'BTC-USD' },
            { symbol: 'ETHUSDT', name: 'Ethereum USD', display: 'ETH-USD' },
            { symbol: 'TONUSDT', name: 'Toncoin USD', display: 'TON-USD' },
            { symbol: 'SOLUSDT', name: 'Solana USD', display: 'SOL-USD' },
            { symbol: 'XRPUSDT', name: 'Ripple USD', display: 'XRP-USD' },
            { symbol: 'DOGEUSDT', name: 'Dogecoin USD', display: 'DOGE-USD' }
        ];

        const store = {};
        let realtimeUpdateInterval = null;
        let isHovering = false;

        function init() {
            // Применяем тему сразу при запуске
            applyTelegramTheme();

            // Слушаем изменение темы в реальном времени (например, если пользователь сменил тему в настройках ТГ не закрывая апп)
            window.Telegram.WebApp.onEvent('themeChanged', applyTelegramTheme);

            const listContainer = document.getElementById('stockListContainer');
            
            WATCHLIST.forEach(coin => {
                store[coin.symbol] = {
                    ...coin,
                    price: 0,
                    changeP: 0,
                    history: [],
                    detailHistory: [],
                    currentCandles: [],
                    element: null,
                    chartCtx: null,
                    high24h: 0,
                    low24h: 0
                };

                const div = document.createElement('div');
                div.className = 'stock-item';
                div.innerHTML = `
                    <div class="stock-info">
                        <span class="symbol">${coin.display}</span>
                        <span class="name">${coin.name}</span>
                    </div>
                    <div class="mini-chart">
                        <canvas id="chart-${coin.symbol}"></canvas>
                    </div>
                    <div class="stock-price-block">
                        <span class="price" id="price-${coin.symbol}">--</span>
                        <div class="change-badge" id="badge-${coin.symbol}">--%</div>
                    </div>
                `;
                div.onclick = () => openDetail(coin.symbol);
                listContainer.appendChild(div);

                store[coin.symbol].element = div;
                
                const canvas = document.getElementById(`chart-${coin.symbol}`);
                canvas.width = canvas.parentElement.offsetWidth * 2;
                canvas.height = canvas.parentElement.offsetHeight * 2;
                store[coin.symbol].chartCtx = canvas.getContext('2d');
            });

            fetchHistoryData();
            connectWebSocket();
            setupChartInteractions();
        }

        async function fetchHistoryData() {
            for (let coin of WATCHLIST) {
                try {
                    const res = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${coin.symbol}&interval=60&limit=50`);
                    const data = await res.json();
                    if (data.retCode === 0 && data.result && data.result.list) {
                        const closes = data.result.list.map(k => parseFloat(k[4])).reverse();
                        store[coin.symbol].history = closes;
                        
                        const allPrices = data.result.list.flatMap(k => [parseFloat(k[2]), parseFloat(k[3])]);
                        store[coin.symbol].stats = {
                            high: Math.max(...allPrices),
                            low: Math.min(...allPrices),
                            open: parseFloat(data.result.list[data.result.list.length-1][1])
                        };
                        drawMiniChart(coin.symbol);
                    }
                } catch (e) { console.error(e); }
            }
        }

        function drawMiniChart(symbol) {
            const data = store[symbol].history;
            if (!data.length) return;
            const ctx = store[symbol].chartCtx;
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min || 1;
            const isUp = data[data.length - 1] >= data[0];
            
            ctx.strokeStyle = isUp ? '#30d158' : '#ff453a';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            
            const step = width / (data.length - 1);
            data.forEach((price, i) => {
                const x = i * step;
                const y = height - ((price - min) / range) * (height * 0.8) - (height * 0.1);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function connectWebSocket() {
            const ws = new WebSocket('wss://stream.bybit.com/v5/public/spot');
            ws.onopen = () => {
                const args = WATCHLIST.map(c => `tickers.${c.symbol}`);
                ws.send(JSON.stringify({ "op": "subscribe", "args": args }));
            };
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.topic && msg.topic.includes('tickers')) {
                    const data = msg.data;
                    const symbol = msg.topic.split('.')[1];
                    updateUI(symbol, data);
                }
            };
            ws.onclose = () => setTimeout(connectWebSocket, 3000);
        }

        function updateUI(symbol, data) {
            if (!store[symbol]) return;
            const price = parseFloat(data.lastPrice);
            const changeP = parseFloat(data.price24hPcnt) * 100;
            const volume = data.volume24h;
            
            if (price) store[symbol].price = price;
            if (!isNaN(changeP)) store[symbol].changeP = changeP;
            if (volume) store[symbol].volume = volume;
            if (data.highPrice24h) store[symbol].high24h = parseFloat(data.highPrice24h);
            if (data.lowPrice24h) store[symbol].low24h = parseFloat(data.lowPrice24h);

            const priceEl = document.getElementById(`price-${symbol}`);
            const badgeEl = document.getElementById(`badge-${symbol}`);
            if (price) priceEl.innerText = formatPrice(price);
            if (!isNaN(changeP)) {
                const sign = changeP >= 0 ? '+' : '';
                badgeEl.innerText = `${sign}${changeP.toFixed(2)}%`;
                badgeEl.className = 'change-badge ' + (changeP >= 0 ? 'up' : 'down');
            }

            if (currentDetailSymbol === symbol && !isHovering) {
                updateDetailView(symbol);
                if (store[symbol].detailHistory.length > 0) {
                    const updatedHistory = [...store[symbol].detailHistory];
                    updatedHistory[updatedHistory.length - 1] = price;
                    drawMainChart(symbol, updatedHistory);
                }
            }
        }

        function formatPrice(p) {
            if (p > 1000) return p.toLocaleString('ru-RU', {maximumFractionDigits: 2});
            if (p > 1) return p.toLocaleString('ru-RU', {minimumFractionDigits: 2, maximumFractionDigits: 4});
            return p.toLocaleString('ru-RU', {minimumFractionDigits: 4, maximumFractionDigits: 6});
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString('ru-RU', { 
                day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' 
            });
        }

        // --- DETAIL VIEW & INTERACTION ---

        let currentDetailSymbol = null;
        let currentInterval = 'D';
        let currentLimit = 30;

        function openDetail(symbol) {
            currentDetailSymbol = symbol;
            isHovering = false;
            document.getElementById('detailView').classList.add('active');
            
            // Если в Телеграм есть кнопка "Назад", показываем её
            if(window.Telegram.WebApp.BackButton) {
                window.Telegram.WebApp.BackButton.show();
                window.Telegram.WebApp.BackButton.onClick(closeDetail);
            }

            document.getElementById('dSymbol').innerText = store[symbol].display;
            document.getElementById('dName').innerText = store[symbol].name;
            document.getElementById('dHoverDate').innerText = "";
            
            updateDetailView(symbol);
            loadDetailChart(symbol, currentInterval, currentLimit);
            startRealtimeUpdates();

            const filters = document.querySelectorAll('.filter-btn');
            filters.forEach(btn => {
                btn.onclick = () => {
                    filters.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentInterval = btn.dataset.interval;
                    currentLimit = parseInt(btn.dataset.limit);
                    loadDetailChart(currentDetailSymbol, currentInterval, currentLimit);
                };
            });
        }

        function closeDetail() {
            document.getElementById('detailView').classList.remove('active');
            
            // Скрываем нативную кнопку назад
            if(window.Telegram.WebApp.BackButton) {
                window.Telegram.WebApp.BackButton.hide();
            }

            currentDetailSymbol = null;
            isHovering = false;
            if (realtimeUpdateInterval) clearInterval(realtimeUpdateInterval);
        }

        function startRealtimeUpdates() {
            if (realtimeUpdateInterval) clearInterval(realtimeUpdateInterval);
            realtimeUpdateInterval = setInterval(() => {
                if (currentDetailSymbol && store[currentDetailSymbol] && !isHovering) {
                    const symbol = currentDetailSymbol;
                    const price = store[symbol].price;
                    if (store[symbol].detailHistory.length > 0 && price) {
                        const updatedHistory = [...store[symbol].detailHistory];
                        updatedHistory[updatedHistory.length - 1] = price;
                        drawMainChart(symbol, updatedHistory);
                    }
                }
            }, 2000);
        }

        async function loadDetailChart(symbol, interval, limit) {
            const loading = document.getElementById('chartLoading');
            loading.style.display = 'block';
            
            try {
                const res = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${interval}&limit=${limit}`);
                const data = await res.json();
                
                if (data.retCode === 0 && data.result && data.result.list) {
                    const list = data.result.list;
                    store[symbol].currentCandles = list.map(k => ({
                        t: parseInt(k[0]), o: parseFloat(k[1]), h: parseFloat(k[2]), l: parseFloat(k[3]), c: parseFloat(k[4]), v: parseFloat(k[5])
                    })).reverse();
                    
                    const closes = store[symbol].currentCandles.map(c => c.c);
                    const highs = store[symbol].currentCandles.map(c => c.h);
                    const lows = store[symbol].currentCandles.map(c => c.l);
                    
                    store[symbol].detailHistory = closes;
                    store[symbol].stats = {
                        high: Math.max(...highs),
                        low: Math.min(...lows),
                        open: parseFloat(list[list.length-1][1]),
                        volume: store[symbol].currentCandles.reduce((a, b) => a + b.v, 0)
                    };
                    
                    updateDetailView(symbol);
                    drawMainChart(symbol, closes);
                }
            } catch (e) { console.error(e); } finally { loading.style.display = 'none'; }
        }

        function updateDetailView(symbol, overridePrice = null, overrideChange = null) {
            const data = store[symbol];
            const dPrice = document.getElementById('dPrice');
            const dChange = document.getElementById('dChange');
            
            const currentPrice = overridePrice !== null ? overridePrice : data.price;
            dPrice.innerText = formatPrice(currentPrice);
            
            let changeP, changeVal;
            if (overrideChange !== null) {
                const startPrice = data.detailHistory[0];
                changeVal = currentPrice - startPrice;
                changeP = (changeVal / startPrice) * 100;
            } else {
                changeP = data.changeP;
                changeVal = currentPrice * (changeP / 100);
            }

            const sign = changeP >= 0 ? '+' : '';
            dChange.innerText = `${sign}${changeVal.toFixed(2)} (${sign}${changeP.toFixed(2)}%)`;
            dChange.className = 'detail-change ' + (changeP >= 0 ? 'text-up' : 'text-down');

            if (!isHovering) {
                if (data.stats) {
                    document.getElementById('sOpen').innerText = formatPrice(data.stats.open);
                    document.getElementById('sHigh').innerText = formatPrice(data.stats.high);
                    document.getElementById('sLow').innerText = formatPrice(data.stats.low);
                    document.getElementById('sVol').innerText = (data.stats.volume / 1000).toFixed(1) + 'K';
                }
                if (data.high24h) document.getElementById('sHigh24').innerText = formatPrice(data.high24h);
                if (data.low24h) document.getElementById('sLow24').innerText = formatPrice(data.low24h);
            }
        }

        function setupChartInteractions() {
            const canvas = document.getElementById('mainChart');
            const handleMove = (xClient) => {
                if (!currentDetailSymbol || !store[currentDetailSymbol].detailHistory.length) return;
                
                isHovering = true;
                const rect = canvas.getBoundingClientRect();
                const x = xClient - rect.left;
                
                const data = store[currentDetailSymbol].detailHistory;
                const index = Math.max(0, Math.min(data.length - 1, Math.floor((x / rect.width) * data.length)));
                
                const hoverPrice = data[index];
                const candles = store[currentDetailSymbol].currentCandles;
                const hoverDate = candles[index] ? candles[index].t : null;

                updateDetailView(currentDetailSymbol, hoverPrice, 0);
                if(hoverDate) document.getElementById('dHoverDate').innerText = formatDate(hoverDate);

                drawMainChart(currentDetailSymbol, data, index);
            };

            const handleLeave = () => {
                if (!isHovering) return;
                isHovering = false;
                document.getElementById('dHoverDate').innerText = "";
                updateDetailView(currentDetailSymbol);
                drawMainChart(currentDetailSymbol, store[currentDetailSymbol].detailHistory);
            };

            canvas.addEventListener('mousemove', (e) => handleMove(e.clientX));
            canvas.addEventListener('mouseleave', handleLeave);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); }, { passive: false });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); }, { passive: false });
            canvas.addEventListener('touchend', handleLeave);
        }

        function drawMainChart(symbol, dataPoints, activeIndex = null) {
            const canvas = document.getElementById('mainChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth * 2;
            canvas.height = container.offsetHeight * 2;
            
            const data = dataPoints || store[symbol].detailHistory;
            if (!data || !data.length) return;

            const width = canvas.width;
            const height = canvas.height;
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min || 1;
            
            const isUp = data[data.length - 1] >= data[0];
            const color = isUp ? '#30d158' : '#ff453a';

            ctx.clearRect(0, 0, width, height);

            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            // Используем color, но с прозрачностью. Это выглядит нормально и на белом, и на черном.
            if(isUp) {
                gradient.addColorStop(0, 'rgba(48, 209, 88, 0.4)');
                gradient.addColorStop(1, 'rgba(48, 209, 88, 0)');
            } else {
                gradient.addColorStop(0, 'rgba(255, 69, 58, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 69, 58, 0)');
            }

            const step = width / (data.length - 1);
            const getY = (val) => height - ((val - min) / range) * (height * 0.85) - (height * 0.1);

            ctx.beginPath();
            data.forEach((price, i) => {
                const x = i * step;
                const y = getY(price);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.beginPath();
            data.forEach((price, i) => {
                const x = i * step;
                const y = getY(price);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 5;
            ctx.strokeStyle = color;
            ctx.stroke();

            if (activeIndex !== null && activeIndex >= 0 && activeIndex < data.length) {
                const activePrice = data[activeIndex];
                const activeX = activeIndex * step;
                const activeY = getY(activePrice);

                ctx.beginPath();
                ctx.moveTo(activeX, 0);
                ctx.lineTo(activeX, height);
                ctx.lineWidth = 1;
                // Цвет линии перекрестия берем из CSS переменной для текста
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text-sec'); 
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(activeX, activeY, 12, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(activeX, activeY, 12, 0, Math.PI * 2);
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--bg-color'); // Обводка в цвет фона
                ctx.lineWidth = 4;
                ctx.stroke();

            } else {
                const lastX = (data.length - 1) * step;
                const lastY = getY(data[data.length - 1]);
                ctx.beginPath();
                ctx.arc(lastX, lastY, 8, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        init();
    </script>
</body>
</html>